---
Title: Visualization of Sentinel-2 GeoJSON Data
Description: Developer diary for rendering data from an EOX REST service, that serves geojson describing Sentinel2 satellite images.
Author: Thomas Ortner
Date: 2018-11-06
Robots: noindex,nofollow
Template: blog-post
---
# Visualization of Sentinel-2 GeoJSON Data

## Project Goal

EOX is our partner in the Minerva project, and they specialize in geospatial databases. EOX and most of their projects are very keen on supporting open standards such as OGC and so on. In the course of their collaboration with ESA in the Copernicus programme they built a public interface to Earth observation data collected by the Sentinel-2 orbiter available as a REST service. Nowadays, everything is a REST service, which simple means that certain parameters in a URL are your query parameters and you get data back via an http request, typically an xml or json file. This URL provides a REST service adhereng to open search standards [http://ows.eox.at/evo-odas/eoxserver/opensearch/collections/sentinel2/json/](http://ows.eox.at/evo-odas/eoxserver/opensearch/collections/sentinel2/json/). Our goal is to build a small mockup with Aardvark.Media, which queries this REST service and interprets and visualizes the data provided in the form of GeoJSON.

## Preparation

First, we spend some time on planning and make a short roadmap consisting of milestone. Each milestone is a runnable prototype, which in the best case visualizes something. In the most general way, our application will be a concatenation of mappings, transforming our input data a couple of times until we see pixels on the screen. Most of the apps we program can be characterized this way, some give it a fancy name like "the data flow" pattern, but that's a 100 dollar name for a 1 dollar concept.

In the functional world, transformations are functions, and the things we transform are types. A first sketch for this program, for the whole program btw, may look like this: `.json -> Model -> ISg`. From that we can create a module that will have the following functions:

```javascript
module GeoJson =
  
  type Model = {
    data : int
  }

  let load (jsonFile : string) : Model = failwith "not implemented"

  let view (m : Model) : ISg = failwith "not implemented"

```

And these two transformations are already our two milestones

* Milestone A: Parse and load json data into model
* Milestone B: Transform model to Sgs and view data

This is the initial step to every new feature we implement: Take a step back, think about the types (we didn't do that really), think about the transformations and then build a small media scratch, which is an empty husk with a lot of `failwith`s and dummy types. 

To build a media scratch do the following:

* clone media and checkout/switch to master
* open media with vs, locate the scratch folder and open new.fsx
* Ctrl+A, Alt+Enter sends the code to fsharp interactive
* Type in a name for your scratch in the interactive console
* Let vs reload the project file
* Commit and push empty scratch project to media master

When starting the Scratch project an Aardvark will greet you!

![Aardvark](%base_url%/images/aardvark.png)

The script 'new.fsx' is an fsharp script, which parses the current solution file, determines the index number of the new scratch project and appends it to the currently open media solution, hence the reload is necessary.

## Loading the Data

Let's have a look at what data we want to load and open the [EOX link](http://ows.eox.at/evo-odas/eoxserver/opensearch/collections/sentinel2/json/) in Firefox to get the following, human readable json printout:

![Aardvark](%base_url%/images/sentinelgeojson.png)

Next, we look for an fsharp library that can "load" a json file. It is difficult to answer what a suitable library is. We could for instance use a [type provider]("http://fsharp.github.io/FSharp.Data/library/JsonProvider.html"), which would automatically infer a domain model for us from a sample json file. Since our data will always look the same, and we want control on what data we read and how we will represent it we use the [JSON parser]("http://fsharp.github.io/FSharp.Data/library/JsonValue.html") on top of which the type provider is built.

### Integrating a JSON parser

We look at the JSON parser documentation and try to execute the example code within our loading function

```javascript
namespace GeoJsonViewer

open Aardvark.Base
open FSharp.Data

module GeoJSON =

  let load (jsonFile : string) : Model = 
    let info =
      JsonValue.Parse(""" 
        { "name": "Tomas", "born": 1985,
          "siblings": [ "Jan", "Alexander" ] } """)

    Log.line "%A" info
    { value = 0 }
```

In this case JSON data cannot be found, we need to reference the FSharp.Data package first. We need to perform the following steps to integrate a new package:

* lookup the newest package version on nuget, in our case this is 3.0.0 on [link](https://www.nuget.org/packages/FSharp.Data)
* add the package and version to the `paket.dependencies` file, `nuget FSharp.Data ~> 3.0.0`
* add the package to the `paket.references` file in our project `FSharp.Data`
* close visual studio and call `.\.paket\paket install` which generates an updated `paket.lock` file and updates the references in the project files. This is important: we do NOT need to add references via visual studio, paket does all that

Reopening Aardvark.Media we discover that `JsonValue` can actually be found and as a next step we just call our code. A nice variant would be to use fsharp interactive, but I always have difficulties to set that up properly. Using CTRL+F5 really starts up fast in case we just want to look at the result and don't want to debug. Calling the above code looks like this:

```javascript
GeoJSON.load "" |> ignore
Console.Read() |> ignore
Environment.Exit(0)

//console output
0: {
  "name": "Tomas",
  "born": 1985,
  "siblings": [
    "Jan",
    "Alexander"
  ]
}
```

We have reached the first step to MilestoneA, we can parse a piece of json and output it onto the console. We wrote a very small piece of code and immediatly verified if it does what we expect it to do. Further, our code does always compile due to `failwith` and dummy data types. This is a very crude test driven approach, where we actually don't write any tests :D

### Parsing the real data

We follow the documentation of FSharp data and try to load our real data from file. Therefore we need to download it first and save it as `eox.json` into the data folder of Aardvark.Media.

```javascript

module GeoJSON =
  let load (jsonFile : string) : Model = 
    let info = JsonValue.Load(jsonFile)
    Log.line "%A" info
    { value = 0 }


GeoJSON.load @"..\..\..\data\eox.json" |> ignore
Console.Read() |> ignore
Environment.Exit(0)


//console output ... cut off by pretty print %A
0: {
  "type": "FeatureCollection",
  "bbox": [
    7.386474,
    -19.078916,
    50.147561,
    49.652723
  ],
  "features": [
    {
      "type": "Feature",
      "properties": {
        "id": "S2A_MSIL1C_20170501T100031_N0205_R122_T33TUN_20170501T100029.SAFE",
        "begin_time": "2017-05-01T10:00:31.026000Z",
        "end_time": "2017-05-01T10:00:31.026000Z"
      },
      "bbox": [
        12.777443,
        46.842299,
        13.816648,
        47.847371
      ],
      "geometr... 
```